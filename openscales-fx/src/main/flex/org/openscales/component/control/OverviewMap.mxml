<?xml version="1.0" encoding="utf-8"?>
<control:Control xmlns:mx="http://www.adobe.com/2006/mxml"
	xmlns:control="org.openscales.component.control.*"
	xmlns:os="http://openscales.org"
	width="100" height="100"
	creationComplete="finalizeOverview();"
	resize="resizeOverview();">
	
	<mx:Script>
		<![CDATA[
			import org.openscales.core.basetypes.Bounds;
			import org.openscales.core.basetypes.LonLat;
			import org.openscales.core.basetypes.Pixel;
			import org.openscales.core.basetypes.Size;
			import org.openscales.core.events.LayerEvent;
			import org.openscales.core.events.MapEvent;
			import org.openscales.core.geometry.Geometry;
			import org.openscales.core.layer.Layer;
			import org.openscales.core.Map;
			import org.openscales.core.Trace;

			import com.gskinner.motion.GTweeny;
			import mx.events.SliderEvent;
			import flash.geom.Rectangle;

			// FixMe : replace all LonLat by Abstract2D. Sometimes it is LonLat, other times it's Projected Coordinate and some other times it is Pixel !!!
 
 			private var rect:Shape = new Shape(); // the rectangle that represents the visible extent of the main map over the overview map
			private var rectRealPxBounds:Bounds = new Bounds(0, 0+height, 0+width, 0); // the real extent in pixels associated to the visible extent of the main map
			private var sprite:Sprite // the sprite used to display the "rect"
	    	private var drawingExtentFirstCorner:Pixel; // the first corner defined for a definition of a new extent by drawing on the overview map
			
			[Bindable] public var _minRectPxSize:Number = 5; // the display of the rect is limited to a minimum width and height of minRectPxSize pixels
			public function get minRectPxSize():Number {
				return _minRectPxSize;
			}
			public function set minRectPxSize(value:Number):void {
				if (value > 0) {
					_minRectPxSize = value;
				}
			}
			
			[Bindable] public var _rectColor:uint = 0xFF0000; // the color of the rect that represents the visible extent of the main map
			public function get rectColor():uint {
				return _rectColor;
			}
			public function set rectColor(value:uint):void {
				_rectColor = value;
			}
			
			[Bindable] public var _newExtentColor:uint = 0x0000FF; // the color of the extent defined with a drawing on the overview map
			public function get newExtentColor():uint {
				return _newExtentColor;
			}
			public function set newExtentColor(value:uint):void {
				_newExtentColor = value;
			}
			
			/**
			 * Init the overview once the creation is completed
			 */
			private function finalizeOverview():void {
				// Override the base layer if defined
				// TODO
				/*var child:DisplayObject;
				for(i:int=0; i < this.rawChildren.numChildren; i++) {
					child = this.rawChildren.getChildAt(i);
					if (child is FxLayer) {
						(child as FxLayer).fxmap = this;
						this.overview.map.addLayer((child as FxLayer).layer);
					}
				}*/
				
				// Create the sprite that will display the rect and add to the overview
				sprite = new Sprite();
				sprite.addChild(rect);
				overview.map.addChild(sprite);
			
				// Change the center of the main map to the location clicked on the overview
				overview.map.addEventListener(MouseEvent.CLICK, setCenterFromOverview);
				
				// Change the center and the scale of the main map depending on the new extent drawn on the overview map
				//overview.map.addEventListener(MouseEvent.MOUSE_DOWN, startDrawingExtent);
			}
			
			/**
			 * Resize the overview to fit to the maximum size avaible for this component
			 */
			private function resizeOverview():void {
			    overview.width = width;
			    overview.height = height;
			}

			/**
			 * Convert a coordinate on the overview map in a Pixel on the overview component
			 * 
			 * @param cx the X-coordinate of a point of the overview map
			 * @param cy the Y-coordinate of a point of the overview map
			 */
			private function coordinateToPixel(cx:Number, cy:Number):Pixel {
		        var invRes:Number = 1.0 / overview.map.resolution;
            	return new Pixel(
                    Math.round(invRes * (cx - overview.map.extent.left)),
                    Math.round(invRes * (overview.map.extent.top - cy)));
    		}
    		
			/**
			 * Convert a Pixel on the overview component in a coordinate on the overview map 
			 * 
			 * @param p the pixel on the overview component
			 */
			private function pixelToCoordinate(p:Pixel):LonLat {
		        var c2p_x:Number = p.x - overview.map.size.w / 2.0;
		        var c2p_y:Number = p.y - overview.map.size.h / 2.0;
		        var center:LonLat = overview.map.extent.centerLonLat;
		        return new LonLat(	center.lon + c2p_x * overview.map.resolution,
		        					center.lat - c2p_y * overview.map.resolution );
    		}
    		
			/**
			 * Change the main map associated to the overview, define the event
			 * listeners attached to the map and redraw the rectangle that represents
			 * the visible extent of the main map.
			 * If the new map is null, the listeners attached to the previous
			 * main map are removed and the rectangle is drawn using the
			 * maximum size.
			 */		
			override public function set map(value:Map):void {
				// Do nothing if the name of the new map is the name of the current map
				/*if (value.name == map.name) {
					return;
				}*/

				// Remove the event listeners defined on the previous main map
	      		if (map != null) {
					// Remove the listeners on when the main map is moved or zoomed	
	     			map.removeEventListener(MapEvent.MOVE_END, updateRectFromMainMap); 
	     			map.removeEventListener(MapEvent.ZOOM_END, updateRectFromMainMap);

					// Remove the listeners on when the base layer of the main map is changed	
					map.removeEventListener(LayerEvent.BASE_LAYER_CHANGED, updateRectFromMainMap);
	      		}
	      		
	      		// Change the main map associated to the overview map
	      		super.map = value;
      			// Zoom out the overview to display the maximum extent of its map
				overview.map.zoomToMaxExtent();
				// Update the rectangle of the overview that represents the visible extent of the main map (even if null)
				updateRectFromMainMap();
	      		
	      		// Add the event listeners to the new main map
	      		if (map != null) {
					// Update the overview when the main map is moved or zoomed	
					map.addEventListener(MapEvent.MOVE_END, updateRectFromMainMap);			
					map.addEventListener(MapEvent.ZOOM_END, updateRectFromMainMap);
					
					// Change the overview map if the base layer of the main map is changed
					map.addEventListener(LayerEvent.BASE_LAYER_CHANGED, updateRectFromMainMap);
	      		}
			}
			
			/**
			 * Update the main map from the current position and size of the rectangle of the overview
			 */
			private function updateMainMapFromRect():void {
				Trace.info("Overview - updateMainMapFromRect");
				if (map == null) {
					// Main map is not defined, nothing has to be done	
					return;
				}
				// Convert the current pixels'boundary in a map extent in the projection of the overview map
		        var leftBottomCoord:LonLat = pixelToCoordinate(new Pixel(rectRealPxBounds.left, rectRealPxBounds.bottom));
		        var rightTopCoord:LonLat = pixelToCoordinate(new Pixel(rectRealPxBounds.right, rectRealPxBounds.top));
				var mapBounds:Bounds = new Bounds(leftBottomCoord.lon, leftBottomCoord.lat, rightTopCoord.lon, rightTopCoord.lat);
				// If necessary, convert mapBounds in the projection of the main map	
				if (map.projection != overview.map.projection) {
					mapBounds.transform(overview.map.projection,map.projection);
				}
				// Update the visible extent of the main map
        		map.zoomToExtent(mapBounds);
				// The update of the main map will call an update of the overview.
				// It is normal since the extent drawn on the overview map is not
				// constrained by the aspect ratio of the main map nor by its eventual
				// predefined scales.
			}
    
			/**
			 * Update the overview when the main map is moved or zoomed
			 * 
			 * @param event the event is not used to perform the update, the main map is sufficient
			 */
			private function updateRectFromMainMap(event:Event=null):void {
				var mapBounds:Bounds;
				if (map == null) {
					Trace.warning("Overview - updateRectFromMainMap("+((event==null)?"null":event.type)+") : stop, map is null");
					// Main map is not defined, the extent of the overview map is used instead	
					mapBounds = overview.map.extent;
				} else {
					Trace.info("Overview - updateRectFromMainMap("+((event==null)?"null":event.type)+") : resolution=" + map.resolution + " ; " + map.center.toString());
					// Get the current main map's extent	
					mapBounds = map.extent;
					// Intersect the map extent with its maxExtent
					// TODO: is this part really necessary ? Test with a overview having a small maxExtent
					var mapMaxExtent:Bounds = map.maxExtent;
					mapBounds.left = Math.max(mapBounds.left, mapMaxExtent.left);
					mapBounds.bottom = Math.max(mapBounds.bottom, mapMaxExtent.bottom);
					mapBounds.right = Math.min(mapBounds.right, mapMaxExtent.right);
					mapBounds.top = Math.min(mapBounds.top, mapMaxExtent.top);
					// Reproject the extent in the projection of the overview map	
					if (overview.map.projection != map.projection) {
						mapBounds.transform(map.projection,overview.map.projection);
					}
					// Intersect the (reprojected) map extent with the overview map maxExtent
					var overviewMapMaxExtent:Bounds = overview.map.maxExtent;
					mapBounds.left = Math.max(mapBounds.left, overviewMapMaxExtent.left);
					mapBounds.bottom = Math.max(mapBounds.bottom, overviewMapMaxExtent.bottom);
					mapBounds.right = Math.min(mapBounds.right, overviewMapMaxExtent.right);
					mapBounds.top = Math.min(mapBounds.top, overviewMapMaxExtent.top);
				}
				// Convert the extent in pixels
		        var leftBottomPx:Pixel = coordinateToPixel(mapBounds.left, mapBounds.bottom);
		        var rightTopPx:Pixel = coordinateToPixel(mapBounds.right, mapBounds.top);
				// Update the rectangle that represents the visible extent
				setPxBoundsAndDraw(new Bounds(leftBottomPx.x, leftBottomPx.y, rightTopPx.x, rightTopPx.y));
			}
			
    		/**
    		 * Draw the map extent over the overview map (manage the visible part of the overview map for display)
    		 * 
    		 * @param pxBounds the extent of the main map in pixels over the overview map 
    		 */
			private function setPxBoundsAndDraw(pxBounds:Bounds):void {
				// Save the real boundary in pixel coordinates
		        rectRealPxBounds = pxBounds;

				// For the display, the pixels bounds are not allowed to de defined outside of the visible part of the overview map
				var rectLeft:Number = Math.max(pxBounds.left, 0);
				var rectTop:Number = Math.max(pxBounds.top, 0);
				var rectRight:Number = Math.min(pxBounds.left + pxBounds.width, overview.map.size.w);
				var rectBottom:Number = Math.min(pxBounds.top + pxBounds.height, overview.map.size.h);
				// Compute the width and the height of the visible boundary
				var rectWidth:Number = rectRight - rectLeft;
				var rectHeight:Number = rectBottom - rectTop;

				// If the visible width is lower than the minimum size for the display, change for this minimum size
	       	    if (rectWidth < minRectPxSize) {
		            rectLeft += Math.round((rectWidth-minRectPxSize) / 2);
		            rectWidth = minRectPxSize;
				}
				// If the real height is lower than the minimum size for the display, change for this minimum size
	       	    if (rectHeight < minRectPxSize) {
		            rectTop += Math.round((rectHeight-minRectPxSize) / 2);
		            rectHeight = minRectPxSize;
				}
       	    
				// Draw the rectangle with the corrected values
				// Be Careful : the drawing must be done before setting the width and height of the rect !!
				// Otherwise, in some cases, rect.width and rect.height are setted to zero instead of rectWidth and rectHeight
				rect.graphics.clear();
				rect.graphics.lineStyle(1,rectColor);
				rect.graphics.drawRect(0,0,rectWidth,rectHeight);

				// Update the position and size of the rectangle
				rect.x = rectLeft;
				rect.y = rectTop;
				rect.width = rectWidth;
				rect.height = rectHeight;
    		}
			
    	    /**
    	    * Set the center of the main map to the position defined by a click on the overview map
    	    * 
    	    * @param event the event that contains the position clicked on the overview component
    	    */
    		private function setCenterFromOverview(event:MouseEvent):void {
    			// FixMe : the location of the event should be used instead of the position from overview
    			var click:Pixel = new Pixel(overview.map.mouseX, overview.map.mouseY);

				// Update the overview (and the main map if not null)
				if (map == null) {
					Trace.warning("Overview - setCenterFromOverview : map is null ; " + click.toString());
	    			var oldCenter:Pixel = rectRealPxBounds.centerPixel;
	    			// Compute the displacement then move the real boundary
	    			var delta:Pixel = new Pixel(click.x - oldCenter.x, click.y - oldCenter.y);
	    			rectRealPxBounds.left += delta.x;
	    			rectRealPxBounds.right += delta.x;
	    			rectRealPxBounds.top += delta.y;
	    			rectRealPxBounds.bottom += delta.y;
	    			// Update the display of the visible boundary (needed if the center is changed to a position near a side of the overview map)
	    			setPxBoundsAndDraw(rectRealPxBounds);
				} else {
					Trace.info("Overview - setCenterFromOverview : " + click.toString());
					// Convert the new pixel center in a location on the overview map in its projection
			        var clickCoord:LonLat = pixelToCoordinate(click);
					// If necessary, convert the point in the projection of the main map	
					if (map.projection != overview.map.projection) {
						clickCoord.transform(overview.map.projection,map.projection);
					}
					// Change the center of the main map, and so, indirectly update the overview.
	        		map.center = clickCoord;
				}
			}
			
			/**
			 * Change the base layer of the overview map to the layer defined by the name of the event
			 * 
			 * @param event the event that defines the name of the new base layer to use for the overview map
			 */
			/*private function changeBaseLayer(event:LayerEvent):void  {
				// Do nothing if the name of the event is the name of the current base layer of the overview map
				if (event.layer.name == overview.map.baseLayer.name) {
					return;
				}
				// Get the layer defined by the name of the event
			 	var newBaseLayer:Layer = overview.map.getLayerByName(event.layer.name) as Layer;
			 	// If the layer defined by the name of the event exists, the base layer of the overview map is changed
			 	if (newBaseLayer) {
				 	overview.map.baseLayer.visible = false;
				 	overview.map.baseLayer = newBaseLayer;
				 	overview.map.baseLayer.visible = true;
				}
			}*/
			
			/**
			 * Start to draw a new extent for the main map from the overview map ?
			 * The draw really starts when the mouse moves. If MOUSE_UP occurs
			 * without a MOUSE_MOVE, only the CLICK event is managed (change only
			 * the center of the extent).
			 * 
			 * @param event the event that defines the position of the first corner of the new extent
			 */
			private function startDrawingExtent(event:MouseEvent) : void {
				// Save the clicked Pixel as the first corner of the new extent
				// FixMe : the location of the event should be used instead of the position from overview
				drawingExtentFirstCorner = new Pixel(overview.map.mouseX, overview.map.mouseY);

				// Add the event listener needed to draw of a new extent
				overview.map.addEventListener(MouseEvent.MOUSE_MOVE, drawBoxExtent);
			}
			
			/**
			 * As the mouse moves, it is now sure that the user is drawing a new
			 * extent. Nowadays, the propagation of the events is stop to avoid
			 * the management of the CLICK event.
			 * This function smply draw the current waiting for a MOUSE_UP event
			 * that will define the real new extent. 
			 * 
			 * @param event the event that defines the position of the second corner of the new extent
			 */
            private function drawBoxExtent(event:MouseEvent) : void {
				// Stop the propagation of the event to avoid the management of MouseEvent.CLICK
				event.stopImmediatePropagation();

				// Add the event listener needed to finalize the draw of a new extent
				if (! overview.map.hasEventListener(MouseEvent.MOUSE_UP)) {
					overview.map.addEventListener(MouseEvent.MOUSE_UP, stopDrawingExtent);
				}
				
				// Get the current second corner of the new extent
				// FixMe : the location of the event should be used instead of the position from overview
				var click:Pixel = new Pixel(overview.map.mouseX, overview.map.mouseY);

				// Compute the rectangle defined by the two corners
				var topLeftPixel:Pixel = new Pixel(Math.min(drawingExtentFirstCorner.x,click.x), Math.min(drawingExtentFirstCorner.y,click.y)); 
				var size:Size = new Size(Math.abs(click.x-drawingExtentFirstCorner.x), Math.abs(click.y-drawingExtentFirstCorner.y));
				
				// Draw the current extent
				rect.graphics.clear();
				rect.graphics.lineStyle(1,rectColor);
				rect.graphics.drawRect(0,0,rect.width,rect.height);
				
				// Draw the possible new extent
				sprite.graphics.lineStyle(1,newExtentColor);
				sprite.graphics.beginFill(newExtentColor,0.25);
				sprite.graphics.drawRect(topLeftPixel.x, topLeftPixel.y, size.w, size.h);
				sprite.graphics.endFill();
			}
			
            private function stopDrawingExtent(event:MouseEvent) : void {
				Trace.info("Overview - stopDrawingExtent");

				// Stop the propagation of the event to avoid the management of MouseEvent.CLICK
				event.stopImmediatePropagation();

     			// Remove tthe event listener needed to finalize the draw of a new extent
				overview.map.removeEventListener(MouseEvent.MOUSE_MOVE, drawBoxExtent);
				overview.map.removeEventListener(MouseEvent.MOUSE_UP, stopDrawingExtent);
				
				// Get the current second corner of the new extent
				// FixMe : the location of the event should be used instead of the position from overview
				var click:Pixel = new Pixel(overview.map.mouseX, overview.map.mouseY);

				// Compute the rectangle defined by the two corners
				var topLeftPixel:Pixel = new Pixel(Math.min(drawingExtentFirstCorner.x,click.x), Math.min(drawingExtentFirstCorner.y,click.y)); 
				var size:Size = new Size(Math.abs(click.x-drawingExtentFirstCorner.x), Math.abs(click.y-drawingExtentFirstCorner.y));
				
				// Change the representation of the current extent on the overview map to use the extent drawn
				// TODO
				sprite.graphics.clear();
				
				// Update the main map extent from the overview map extent
				// TODO
			}
		]]>
	</mx:Script>
	
	<os:Map id="overview" height="100%" width="100%">
		
		<!-- Default base layer: OpenStreetMap EPSG:900913 -->
		<os:Mapnik name="Default(OSM-Mapnik)"
			numZoomLevels="20"
			maxExtent="-20037508.34,-20037508.34,20037508.34,20037508.34"
			minResolution="0.5971642833709717"
			maxResolution="156543.0339"
			isBaseLayer="true" />
		
	</os:Map>

</control:Control>
